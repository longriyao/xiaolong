---
layout: post
title: Brophp教程笔记2-后台管理系统登陆模块
description: ""
categories: [web]
tags: [php]
---

#Login模块：

这节课我想换一种记笔记的方式。用一用费曼技巧，把自己当做老师，想想自己是在给大家讲课。不过有些问题我也没想清楚。想到多少就写多少吧。

这节课我们要写一个登陆模块。我想最好先搞清楚几个问题，1什么是登陆模块？这个大家见得很多，平时登陆网站都要注册和登陆。 2 为什么要有登陆模块。所谓的登陆实质就是一种身份验证，就像是我们的身份证一样。登陆之后网站就知道你是谁，当你网购的时候，想把一件商品加入你的购物车里，就必须登陆，要不然网站就不知道该把这件商品放到谁的账户下。现在很多网站都是必须登陆之后才能访问，Facebook，Medium,还有国内的十五言都是必须登陆才能访问。由于咱们做的是后台管理系统，所以也必须登陆之后才能访问。要不然就别人随随便便的就访问到你的后台了。

那么我们该如何实现呢？
首先明确的是我们要实现的是，除非已经登录，否则访问任何后台页面都只会跳转到登录页面（这句话等价于登陆任何页面都要做验证）。

根据MVC思想，我们很容易想到，最好把登录功能单独做成一个独立的模块。即有一个Login的控制器，控制器里有 显示登录界面，以及登录，登出等操作。还有登录界面的视图模板。不过还是那个老问题，到底在那里做身份验证？或者说在哪里验证是否登录了？

在登录模块里？ 这可能是很多人容易想到的，但是请务必搞清楚如果这样设计的话，就意味着只有别人访问你的登陆模块的时候才能进行验证了。达不到我们要求的任何页面都做验证。 

说到这里我想到一个例子。从a地到b地有很过条路。假如我们在半途中设关卡来拦击某人，除非我们把在每条路上都设卡，但是现实中人们都不傻，一般都会选择在必经之路上设卡，例如京城的大门，例如被鬼子占领的县城的大门。

由此的到启发，我们只需要在一条必经之路上做身份验证就可以啦。现在问题就转化成寻找那条“必经之路”。

好吧如果听说过Brophp框架的文件继承关系你已经知道跳必经之路在哪里了。就是common.class.php 这个公共文件。我们生产的任何控制器模块（例如前一节的index模块，和这一节的Login模块）都会默认继承自 common模块。而它的第一行写着

    class Common extends Action { 

说明它又继承自 Action 模块。当你在好奇心的驱使下打开Action模块的文件你又会发现它继承自MyTpl模块。这还没完 MyTpl继承自Smarty模块。继承关系如下图。


![](http://xiaolei.info/images/web/php/1.jpg)



实现验证的代码如下：
[admin/controls/common.class.php]

    <?php
        class Common extends Action {
            function init(){
                if(!(isset($_SESSION['isLogin']) && $_SESSION['isLogin'] === 1)) {
                    $this->redirect('login/index');
                }
            }   
        }

其中 isset($_SESSION['isLogin']) && $_SESSION['isLogin'] === 1 是利用SESSION来验证是否登录。（我所理解的SESSION的本质就是一种数据的保存方式，目的是让一个用户的数据方便随时取用）。

接着我们可以开始写Login模块。
[admin/controls/login.class.php（index）]

    <?php
        class Login extends Action {
            function index() {
                debug(0);
                $this->display();
            }
        }

也许有人会奇怪 为什么Login要继承自Action,实际上如果它不继承自Action就会默认继承自common，这样一来Login就被锁住了。也就是说想要登录就要显示登录界面，而登录界面就在Login中，不登陆就不能显示登录界面。看吧自相矛盾了！这里我们只需要继承自Action，让Login与common是一个平级的模块问题就解决了。

#login视图
[admin/views/default/login/index.tpl]

    <html>
        <head>
            <title>用户登录</title>
        </head>

        <body>
            <form action="<{$url}>/login" method="post">
            <table border="1" width="300" align="center">
                <caption><h1>用户登录</h1></caption>

                <tr>
                    <th>用户名称:</th> <td><input type="text" size="20" name="username"></td>
                </tr>
                <tr>
                    <th>用户密码:</th> <td><input type="password" size="20" name="password"></td>
                </tr>
                <tr>
                    <td align="center" colspan="2"><input type="submit" value="登 录"></td>
                </tr>
            </table>
        </body>
    </html>

登录数据被提交到当前模块下的login操作。

[admin/controls/login.class.php（login）]

    function login() {
        $user = D('user')->field('id, username, one, two, three, four')->where(array('username'=>$_POST['username'], 'password'=>md5($_POST['password'])))->find();

        if($user) {
            $_SESSION=$user;
            $_SESSION['isLogin']=1;

            $this->redirect('index/index');
        } else {
            $this->error('用户登录失败， 请重新登录！',3, "index");
        }

    }
			
    $user = D('user')->field('id, username, one, two, three, four')->where(array('username'=>$_POST['username'], 'password'=>md5($_POST['password'])))->find();//利用提交的数据从数据库中抓取信息，检测是否有此用户

这条语句是从user数据表中查询用户信息。注意密码要用md5加密，因为数据库里的密码是加密过的。

$_SESSION['isLogin']=1;//如果存在用户就置一，表示登陆成功。（isLogin实质是一个用来标志用户是否登录的标志位，就像寄存器的标志位一样，从这个角度来讲，可以把$_SESSION看做FLAGS标志寄存器，他们的功能都是起到标志作用，配合其他操作）
    
登录成功之后，跳转到首页，在top位置显示 "用户你好！"
[admin/views/default/index/top.tpl]

    ...
    用户 <{$smarty.session.username}> 你好!
    <a target="_top" href="<{$app}>/login/logout">退出</a>
    ...

target="_top"  //表示退出时在顶部打开，不在分针内打开。

logout操作
[admin/controls/login.class.php（logout）]

    function logout() {
			$username = $_SESSION['username'];//备份用户名

			$_SESSION=array();//清空session
			
			if(isset($_COOKIE[session_name()])) {
				setCookie(session_name(), '', time()-3600, '/');//干掉cookie
			}
			session_destroy();//粉碎session

			$this->success("再见 {$username}, 退出成功!", 1, "index");
    }	

#权限验证：
[admin/controls/common.class.php]

    <?php
        class Common extends Action {
            function init(){
                if(!(isset($_SESSION['isLogin']) && $_SESSION['isLogin'] === 1)) {
                    $this->redirect('login/index');
                }

                //$_GET['m']  $_GET['a']     user/add

            //	p($_GET);
            //	p($_SESSION);	


                //如果有one的权限， 就能访问 cat模块

                if($_GET['m'] == "cat" && $_SESSION['one'] !=1 ) {
                    $this->error("用户{$_SESSION['username']}权限不足， 你不能管理分类！", 3, "index/index");
                }


                if($_GET['m'] == "cat" && $_GET['a']=="add" && $_SESSION['four'] !=1 ) {
                    $this->error("用户{$_SESSION['username']}权限不足， 你不能管理分类添加！", 3, "index/index");
                }
                if($_GET['m'] == "goods" && $_SESSION['two'] !=1 ) {
                    $this->error("用户{$_SESSION['username']}权限不足， 你不能管理商品！", 3, "index/index");
                }

                if($_GET['m'] == "user" && $_SESSION['three'] !=1 ) {
                    $this->error("用户{$_SESSION['username']}权限不足， 你不能管理用户！", 3, "index/index");
                }


            /*	$arrs= array('cat', 'user', 'goods');

                if(in_array($_GET['m'], $arrs) && $_SESSION['five']!=1) {
                    //权限不足
                } */
            }		
        }
        
所谓的权限验证就是在你执行某个操作的时候检测是否拥有操作的权限。有权限就可以操作没权限就提示错误。我们只需要用条件语句判断没权限的情况进行处理，判断的一个复合逻辑是 执行某项操作且没有该操作权限。
