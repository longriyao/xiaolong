---
layout: post
title: 排序
description: ""
categories: [数据结构]
tags: [数据结构与算法]
---


插入排序
插入排序算法类似于玩扑克时抓牌的过程，玩家每拿到一张牌都要插入到手中已有的牌里，使之从小到大排好序

#include <stdio.h>
#define LEN 5
int a[LEN] = { 10, 5, 2, 4, 7 };
    void insertion_sort(void)
    {
        int i, j, key;
        for (j = 1; j < LEN; ++j) {
        printf("%d, %d, %d, %d, %d\n",a[0], a[1], a[2], a[3], a[4]);
        key = a[j];
        i = j - 1;
        while (i >= 0 && a[i] > key) {
            a[i+1] = a[i];
            --i;
        }

        a[i+1] = key;

        }

        printf("%d, %d, %d, %d, %d\n",a[0], a[1], a[2], a[3], a[4]);
    }
    int main(void)
    {
        insertion_sort();
        return 0;
    }

时间复杂度 n的平方

归并排序
1. Divide: 把长度为n的输入序列分成两个长度为n/2的子序列。
2. Conquer: 对这两个子序列分别采用归并排序。
3. Combine: 将两个排序好的子序列合并成一个最终的排序序列。
在描述归并排序的步骤时又调用了归并排序本身，可见这是一个递归的过程

#include <stdio.h>
#define LEN 8
    int a[LEN] = { 5, 2, 4, 7, 1, 3, 2, 6 };
    void merge(int start, int mid, int end)
    {
        int n1 = mid - start + 1;
        int n2 = end - mid;
        int left[n1], right[n2];
        int i, j, k;
        for (i = 0; i < n1; i++) /* left holds      a[start..mid] */
            left[i] = a[start+i];
        for (j = 0; j < n2; ++j) /* right holds     a[mid+1..end] */
            right[j] = a[mid+1+j];
        i = j = 0;
        for (k = start; i < n1 && j < n2; ++k) {
            if (left[i] < right[j]) {
                a[k] = left[i];
                ++i;
            } else {
                a[k] = right[j];
                ++j;
            }
            }
            if (i < n1) /* left[] is not exhausted */
                for (; i < n1; i++) {
                    a[k] = left[i];
                    ++k;
                }
            if (j < n2) /* right[] is not exhausted */
                for (; j < n2; ++j) {
                a[k] = right[j];
                ++k;
                }
        }

        void sort(int start, int end)
        {
            int mid;
            if (start < end) {
            mid = (start + end) / 2;
            printf("sort (%d-%d, %d-%d) %d %d %d %d%d %d %d %d\n", 
                    start, mid, mid+1, end, a[0], a[1], a[2], a[3], a[4], 
                    a[5], a[6], a[7]);
            sort(start, mid);
            sort(mid + 1, end);
            merge(start, mid, end);
            printf("merge (%d-%d, %d-%d) to %d %d %d %d %d %d %d %d\n", 
                    start, mid, mid+1, end, a[0], a[1], a[2], a[3], a[4], 
                    a[5], a[6], a[7]);
            }
        }

        int main(void)
        {
            sort(0, LEN-1);
            return 0;
        }
result:
sort (0-3, 4-7) 5 2 4 7 1 3 2 6
sort (0-1, 2-3) 5 2 4 7 1 3 2 6
sort (0-0, 1-1) 5 2 4 7 1 3 2 6
merge (0-0, 1-1) to 2 5 4 7 1 3 2 6
sort (2-2, 3-3) 2 5 4 7 1 3 2 6
merge (2-2, 3-3) to 2 5 4 7 1 3 2 6
merge 0-1, 2-3) to 2 4 5 7 1 3 2 6
sort (4-5, 6-7) 2 4 5 7 1 3 2 6
sort (4-4, 5-5) 2 4 5 7 1 3 2 6
merge (4-4, 5-5) to 2 4 5 7 1 3 2 6
sort (6-6, 7-7) 2 4 5 7 1 3 2 6
merge (6-6, 7-7) to 2 4 5 7 1 3 2 6
merge (4-5, 6-7) to 2 4 5 7 1 2 3 6
merge (0-3, 4-7) to 1 2 2 3 4 5 6 7

sort函数把a[start..end]平均分成两个子序列，分别是a[start..mid]和a[mid+1..end
]，对这两个子序列分别递归调用sort函数进行排序，然后调用merge函数将排好序的两
个子序列合并起来，由于两个子序列都已经排好序了，合并的过程很简单，每次循环取
两个子序列中最小的元素进行比较，将较小的元素取出放到最终的排序序列中，如果其
中一个子序列的元素已取完，就把另一个子序列剩下的元素都放到最终的排序序列中

